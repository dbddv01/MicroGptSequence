{
    "get_user_input": "def get_user_input(prompt_text):\n    print(f'\\nUser Input Required:\\n{prompt_text}')\n    return input('Enter your response: ')",
    "generate_response": "def generate_response(prompt_text):\n    payload = {\n        'model': 'gpt-3.5-turbo',\n        'messages': [{'role': 'user', 'content': prompt_text}],\n        'max_tokens': 500\n    }\n    response = requests.post(api_url, json=payload, headers=api_headers)\n    response.raise_for_status()\n    return response.json()['choices'][0]['message']['content']",
    "execute_python_code": "def execute_python_code(python_code):\n    import traceback\n    import importlib\n    import re\n\n    try:\n        # Preprocess code: Remove Markdown code block delimiters\n        if python_code.startswith('```') and python_code.endswith('```'):\n            lines = python_code.splitlines()\n            python_code = '\\n'.join(lines[1:-1])\n\n        # Set up the execution environment\n        exec_globals = {\"__builtins__\": __builtins__}  # Basic built-ins only\n        exec_locals = {}\n\n        # Detect required modules in the code\n        detected_modules = set(re.findall(r'^\\s*(?:import|from)\\s+(\\w+)', python_code, re.MULTILINE))\n\n        # Import detected modules dynamically\n        for module in detected_modules:\n            if module not in exec_globals:\n                try:\n                    exec_globals[module] = importlib.import_module(module)\n                except ImportError:\n                    return f\"Error: Module '{module}' could not be imported.\"\n\n        # Execute the Python code\n        exec(python_code, exec_globals, exec_locals)\n\n        # Collect execution results\n        output = {k: v for k, v in exec_locals.items() if not k.startswith('__')}\n        return f'Execution successful. Variables and outputs:\\n{output}'\n\n    except Exception as e:\n        return f'Error: {str(e)}\\n{traceback.format_exc()}'",
    "extract_python_code": "def extract_python_code(initial_string):\n    import re\n    # Use regex to find the content between ```python and ```\n    match = re.search(r\"```python(.*?)```\", initial_string, re.DOTALL)\n    if match:\n        # Strip any leading/trailing whitespace from the code\n        return match.group(1).strip()\n    else:\n        return \"\"  # Return an empty string if no match is found\n",
    "process_and_save_function_with_backup": "import json\nimport os\nimport shutil\nimport re\nimport csv\n\ndef process_and_save_function_with_backup(function_code, file_name=\"functions.json\"):\n    \"\"\"\n    Parses the function name from the provided code string, backs up the original JSON file,\n    adds or updates the function in the JSON, and creates a corresponding pipe-separated CSV file.\n    The function returns all messages as a concatenated string.\n\n    Args:\n        function_code (str): Input string containing the Python function code.\n        file_name (str): Name of the JSON file to store the functions.\n\n    Raises:\n        ValueError: If a valid function definition is not found in the input string.\n\n    Returns:\n        str: Concatenated messages detailing the operations performed.\n    \"\"\"\n    messages = []\n\n    # Extract function name using regex\n    match = re.search(r\"def\\s+(\\w+)\\s*\\(\", function_code)\n    if not match:\n        raise ValueError(\"No valid function definition found in the provided code.\")\n\n    function_name = match.group(1)\n    messages.append(f\"Extracted function name: {function_name}\")\n\n    # Load existing data if the file exists\n    data = {}\n    if os.path.exists(file_name):\n        # Create a backup before modification\n        backup_file_name = f\"{file_name}.backup\"\n        try:\n            shutil.copy(file_name, backup_file_name)\n            messages.append(f\"Backup created: {backup_file_name}\")\n        except Exception as e:\n            return f\"Error creating backup: {str(e)}\"\n\n        with open(file_name, 'r') as json_file:\n            try:\n                data = json.load(json_file)\n            except json.JSONDecodeError:\n                messages.append(\"Warning: Invalid JSON in the original file. Starting fresh.\")\n\n    # Check for overwrite\n    if function_name in data:\n        messages.append(f\"Warning: Overwriting existing function '{function_name}' in {file_name}.\")\n\n    # Add or update the function in the data\n    data[function_name] = function_code\n\n    # Save the updated data back to the JSON file\n    try:\n        with open(file_name, 'w') as json_file:\n            json.dump(data, json_file, indent=4)\n        messages.append(f\"Function '{function_name}' has been added/updated in {file_name}.\")\n    except Exception as e:\n        return f\"Error saving JSON file: {str(e)}\"\n\n    # Create and save the pipe-separated CSV file\n    csv_file_name = \"test_last_function_created.csv\"\n    csv_data = [\n        [\"Prompt Name\", \"Formatted Prompt\", \"Action\", \"LLM Response\", \"Condition\", \"True Next Prompt\", \"False Next Prompt\", \"Next Prompt\"],\n        [\"Start\", \"\", function_name, \"output\", \"\", \"\", \"\", \"Show\"],\n        [\"Show\", \"Press enter to stop\\nExecution of previous function returned the following : {output}\", \"get_user_input\", \"useranswer\", \"\", \"\", \"\", \"stop\"]\n    ]\n\n    try:\n        with open(csv_file_name, 'w', newline='') as csv_file:\n            writer = csv.writer(csv_file, delimiter='|')\n            writer.writerows(csv_data)\n        messages.append(f\"CSV file '{csv_file_name}' has been created and saved.\")\n    except Exception as e:\n        return f\"Error saving CSV file: {str(e)}\"\n\n    return \"\\n\".join(messages)",
    "restore_backup_json": "import os\nimport shutil\n\ndef restore_backup_json(file_name=\"functions.json\"):\n    \"\"\"\n    Restores the backup JSON file in case the original file is corrupted or lost.\n\n    Args:\n        file_name (str): The name of the main JSON file to be restored.\n\n    Returns:\n        str: A message indicating whether the restoration was successful or not.\n    \"\"\"\n    backup_file_name = f\"{file_name}.backup\"\n\n    if os.path.exists(backup_file_name):\n        try:\n            shutil.copy(backup_file_name, file_name)\n            return f\"Backup restored successfully! '{file_name}' has been replaced with '{backup_file_name}'.\"\n        except Exception as e:\n            return f\"Error restoring backup: {str(e)}\"\n    else:\n        return f\"No backup file found to restore. '{backup_file_name}' does not exist.\"\n",
    "generate_random_word": "import random\nimport string\n\ndef generate_random_word(dummy_string):\n    # Since dummy_string is a null string, we can ignore it.\n    # Generate a random word with 5 letters\n    letters = string.ascii_lowercase\n    return ''.join(random.choice(letters) for _ in range(5))"
}